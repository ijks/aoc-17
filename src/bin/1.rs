extern crate itertools;

use std::iter;

use itertools::Itertools;

const INPUT: &str = "\
    217523428149337669381721216749768791113624176532615223578558168936564624491\
    683773592852448184897238699878612479122897295792966916847611435449569915839\
    422152365689618758517558549779461471787464646752276991499252272271375574797\
    699485697888843993798211113825367226995757594744732739397563489927146679635\
    961897657347431694895991257714433481933835661598435935411347493925698654815\
    783598258443944541732198579193493414421482822296895415611693416222223546513\
    973429286784964786713393839237698564257952113236733897231819679339338327115\
    458856539528618792315379762925178663548129431927282632695247356984233366737\
    351589938535561488338613279592622547566478277391452835777934815267681569211\
    384283189393618597217785562645196434358718357448592431672278895627387129536\
    511283176246739852135258975223782591786254167221521557286159365873695152549\
    368286685648572832264398812668719459987964884722491825388833541865739251831\
    526638626839954496716632857753974538762627225674524359147773635228175947419\
    466389865717936558894664198959969241229157772244994814968373431941491237353\
    552681519417128712458635538369533498878319497888698529291478494892653258439\
    346699993918462863192686867893725139765222825875268661481663372159614935362\
    628515122187941392723612928115298881611987992979668933665531153536392982567\
    888193852724711872135791855235213416511179476767853411462354414114418132425\
    148132278218438194246199749798868716466219188652745745389517615678558456812\
    723646461385847163335998438351673735252485475424429425831226245344944425162\
    596169732358584691311597731673349536586732715997489429569819546994445286896\
    288486944468188254654851228697428397114711298626321286357796583657563628636\
    271359836176133328497563719863769671175492515662819929645739296555893138719\
    765567848492319165138315382548123471162539498186335271851742215652797757667\
    422626877131141143448435349588333726341821768663154415838871777592225988537\
    351141918742777114346538548168415892299141646813644974293244631936693378274\
    676617738335178417637111563761476647491752672125623215677285757658448932327\
    189714712898411716428689488521368186617412381786768573815831555477552198371\
    16125995361896562498721571413742\
";

fn main() {
    println!("part one result:\n{}", part_one());
    println!("part two result:\n{}", part_two());
}

fn part_one() -> u32 {
    let digits = INPUT
            .chars()
            .map(|c| c.to_digit(10).expect("invalid digit"))
            .chain(iter::once(2));
    // Just doing a manual repetition, because I'm too lazy to figure out how to
    // do wraparound with iterators

    digits.tuple_windows()
        .filter_map(|(x, y)| if x == y { Some(x) } else { None })
        .sum()
}

fn part_two() -> u32 {
    let digits = INPUT
        .chars()
        .map(|c| c.to_digit(10).expect("invalid digit"))
        .collect::<Vec<_>>();

    let mut sum = 0;

    for (i, &digit) in digits.iter().enumerate() {
        let next = (i + digits.len() / 2) % digits.len();
        if digit == digits[next] {
            sum += digit;
        }
    }

    sum
}
